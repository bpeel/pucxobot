General notes
=============

The protocol is based on the WebSocket protocol. Once a WebSocket
connection is established, each end sends messages that correspond to
WebSocket messages. Each message begins with a single byte
containining the message ID. After that is the payload. The contents
of the payload depends on the message type, as described below. Each
message must be exactly sized to contain the message ID + the payload,
ie, there can be no extra data at the end of the message.

All numbers are in little-endian.

A player in the game is distinct from the network connection. The
intention is that if the connection is dropped then the client can
reconnect and recover without creating a new player. Instead a player
is identified by a 64-bit ID which is randomly generated by the
server. When connecting the client can either request a new player or
it can send this ID in order to continue with a previous player.

Strings are sent as NULL-terminated UTF-8 text.

Messages to the server
======================

The client initiates the communication by sending one of the following
messages:

NEW_PLAYER (0x80)
-----------------

• string name
• string game_type
• string language_code

This should be sent when the client first starts and hasn't tried
connecting before. The server will create a player ID and send it in a
PLAYER_ID message.

NEW_PRIVATE_PLAYER (0x86)
-------------------------

Same as NEW_PLAYER and with the same parameters. The game that is
created for the player will have a unique ID and won’t be discoverable
by other players. The generated ID will be sent in a PRIVATE_GAME_ID
message.

JOIN_PRIVATE_GAME (0x87)
------------------------

• string name
• uint64_t game_id

Join a game that was previously created with NEW_PRIVATE_PLAYER. If
the game was successfully found then the server will send a player ID
the same as for the NEW_PLAYER_COMMAND. Otherwise it will sent a
PRIVATE_GAME_NOT_FOUND message.

RECONNECT (0x81)
----------------

• uint64_t player_id
• uint16_t n_messages_received

This should be sent if the connection is dropped in order to resume.
The player_id must be a valid ID given from a previous PLAYER_ID
message from the server. num_messages_received should be the number of
messages that the client successfully received from a previous
connection. The server will continue sending messages from that point
on.

BUTTON (0x82)
----------------------

• The data of a button to be pressed. The data to placed here can be
  retrieved from the MESSAGE message.

KEEP_ALIVE (0x83)
-----------------

• No payload

Some data must be sent by the client at least every minute or the
server will close the connection. If nothing else needs to be sent the
client can send this empty message. No response is sent.

LEAVE (0x84)
------------

Leave the current game. It is meant as a friendly way for the client
to inform the server that the player has gone such as by closing the
browser tab. A message will be sent to the game to inform everyone
that the player has left and no further messages will be sent to any
connections listening to this player, even historical ones.

SEND_MESSAGE (0x85)
-------------------

• string text

Send a message to the chat

CLIENT_SIDEBAND (0x88)
----------------------

• uint8_t data_num

Send game-specific sideband data to the server. The data following the
data num depends on the game. Currently this will be one of the
following:

Wordparty:

• TYPED_WORD (0x00)
  • string The in-progress word that the player is currently typing

Messages to the client
======================

PLAYER_ID (0x00)
----------------

• uint64_t player_id

This is sent as the first message whenever NEW_PLAYER or RECONNECT is
sent.

PLAYER_NUM (0x07)
-----------------

• uint8_t player_num

Reports the number of this player within the game.

GAME_TYPE (0x02)
----------------

• string game_type

Reports the type of game. This is mainly useful for private games
where the client doesn’t necessarily know the game type before
joining.

PRIVATE_GAME_ID (0x03)
----------------------

• uint64_t game_id

When a private game is created, the server will send this after
sending the player ID so that other clients can join the game with
JOIN_PRIVATE_GAME.

PRIVATE_GAME_NOT_FOUND (0x04)
-----------------------------

No data

Sent after a JOIN_PRIVATE_GAME message if the requested game doesn’t
exist, it has already started or it is full.

PLAYER_NAME (0x05)
------------------

• uint8_t player number
• string name

When the conversation is first joined, this command will be sent for
each player, including the player who joined, in order to report the
names. It will also be sent whenever a new player joins later.

MESSAGE (0x01)
--------------

• uint8_t message flags
  bit 0: Set if the message is HTML, otherwise plain text
  bits 1-2: Message type:
             0: Public message
             1: Private message sent only to the player
             2: Chat message from another player
             3: Chat message from yourself
• string text

Following the text is a list of buttons terminated until the end of
the payload.

• string data – The data to send to press this button
• string text – The text to display on the button

SIDEBAND (0x06)
---------------

Reports game-specific sideband data that can be used by the client to
visualise the state of the game.

• uint8_t data number

The remaining data depends on the game type and the data number. The
current possible values are:

Wordparty:

• CURRENT_PLAYER (0x00)
  • uint8_t the current player number
• N_LIVES (1-n_players)
  • uint8_t the number of lives for the corresponding player
• SYLLABLE (n_players + 1)
  • string the current syllable to guess
• LAST_RESULT (n_players + 2)
  • uint8_t
    bitfield representing the result of the last word typed in by a player
    bits 0-4: player number
    bits 6-7: 0: word accepted
              1: word rejected
              2: duplicate word
• TYPED_WORD (n_players + 3 - n_players * 2 + 3 - 1)
  • string the last word that this player typed or the word being typed
